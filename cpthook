#!/usr/bin/env python

import inspect
import git
import logging
import os
import os.path
import subprocess
import sys

import cpthook


def parse_options():
    import optparse
    parser = optparse.OptionParser()
    parser.add_option("-c", "--config", dest="config_file", metavar="FILE",
                      default="hook.cfg", help="cpthook config file")
    parser.add_option("-v", "--verbose", dest="verbose", default=False,
                      action="store_true",
                      help="log verbose status information")
    parser.add_option("-d", "--debug", dest="debug", default=False,
                      action="store_true",
                      help="log debug information")
    parser.add_option("--dry-run", dest="dry_run", default=False,
                      action="store_true",
                      help="perform a dry run, making no changes")
    parser.add_option("--init", dest="init", default=False,
                      action="store_true",
                      help="install configured hooks and repositories")
    parser.add_option("--hook", dest="hook", default=None,
                      help="the hook to run against the current repository")
    options, args = parser.parse_args()
    return options, args


def validate_options(opts):
    if not os.path.isfile(opts.config_file):
        print 'No config file "{0}"'.format(opts.config_file)
        sys.exit(-1)

    if opts.init and opts.hook:
        print 'Cannot install to repos and be invoked as a hook'
        sys.exit(-1)

    if opts.hook is not None and opts.hook not in cpthook.supported_hooks:
        print 'Unsupported hook "{0}"'.format(opts.hook)
        sys.exit(-1)


def handle_options():
    opts, args = parse_options()
    validate_options(opts)

    if opts.debug:
        log_level = logging.DEBUG
    elif opts.verbose:
        log_level = logging.INFO
    else:
        log_level = logging.WARN
    logging.getLogger().setLevel(log_level)

    return opts, args


def script_name():
    return os.path.abspath(os.path.realpath(__file__))


def add_hooks_to_repo(repo_path, hooks, config_file, dry_run=False):
    template = (
        "#!/bin/sh\n"
        "#\n"
        "# MAGIC STRING: cpthook-wrapper (do not remove)\n"
        "{0} --config={1} --hook={2}\n"
    )

    hook_path = '/'.join((repo_path, 'hooks'))
    if not os.path.isdir(hook_path):
        logging.warn('Hook path {0} is not a directory'.format(hook_path))
        return

    cpthook = script_name()

    for hook_type in hooks:
        target = '/'.join((repo_path, 'hooks', hook_type))
        if os.path.exists(target):
            if os.path.isfile(target):
                try:
                    f = open(target, 'r')
                except:
                    logging.info('Could not read {0}'.format(target))
                    continue
                header = f.read(100)
                if header.find('cpthook-wrapper') == -1:
                    logging.warn('{0} hook {1} is not managed by cpthook. '
                                 'Refusing to overwrite'.format(
                                     os.path.basename(repo_path), hook_type))
                    continue
            else:
                logging.info('{0} exists but is not a file'.format(target))
                continue

        if dry_run:
            logging.info('Dry run. Skipping write to {0}'.format(target))
            continue

        try:
            wrapper = open(target, 'w')
        except:
            logging.warn('Could not write wrapper {0}'.format(target))
            continue

        try:
            wrapper_script = template.format(cpthook, config_file, hook_type)
            wrapper.write(wrapper_script)
            wrapper.close()
            os.chmod(target, 0755)
            logging.debug('Wrote {0} hook {1}'.format(
                os.path.basename(repo_path), hook_type))
        except:
            logging.warn('Failed to create wrapper {0}'.format(target))


def locate_repo(repo):
    return './{0}'.format(repo)


def install_hooks(config, opts):
    config_file = os.path.realpath(opts.config_file)

    for repo in config.repos():
        logging.debug('Examining repo {0}'.format(repo))
        repo_path = locate_repo(repo)
        if repo is None:
            logging.info('Could not locate repo {0}'.format(repo))
            continue
        hooks = config.hooks_for_repo(repo).keys()
        add_hooks_to_repo(repo_path, hooks, config_file, dry_run=opts.dry_run)

    pass


def run_hook(hook, config, opts, args):
    try:
        gitrepo = git.Repo('.')
    except git.errors.InvalidGitRepositoryError:
        print '{0} is not a git repo?'.format(
            os.path.realpath(os.path.curdir))
        sys.exit(-1)
    # Work out the repository name from the current directory
    repo = os.path.basename(os.path.realpath(os.path.curdir))
    # Determine script path to be in cpthook directory.
    # Work out where that is through some introspection
    script_path = '/'.join((os.path.dirname(
        os.path.abspath(inspect.getfile(inspect.currentframe()))),
        'hooks.d', hook))
    # TODO: make script path a config option
    #script_path = '/'.join(opts.hooksd, hook)
    hooks = config.hooks_for_repo(repo)
    logging.info('{0}'.format(hooks))
    if hook in hooks:
        logging.info('Found {0} hooks'.format(hook))
        for script in hooks[hook]:
            logging.info('Running {0} hook {1}'.format(hook, script))
            if opts.dry_run:
                logging.info('Dry-run: skipping script {0}'.format(
                    script))
                continue
            logging.debug('Calling script {0}'.format(script))
            ret = subprocess.call(['/'.join((script_path, script))] + args)
            if ret != 0:
                logging.info(
                    'Received non-zero return code from {0}'.format(script))
                sys.exit(ret)
    sys.exit(0)


if __name__ == '__main__':
    # Any positional args returned by optparse are intended for
    # the hook script to be invoked.
    opts, hook_args = handle_options()

    try:
        config = cpthook.CptHookConfig(opts.config_file)
    except Exception, e:
        print 'Invalid cpthook config file {0}: {1}'.format(
            opts.config_file, str(e))
        # Exiting with a non-zero code has the potential to disrupt
        # legitimate activity to a repository if we are called as
        # a hook and the configuration file is broken. However, we
        # may also do damage by not running hook scripts that need
        # to run for repositories. It is therefore safest to exit
        # with a non-zero code as while inconvenient this has least
        # potential for damage.
        sys.exit(-1)

    if opts.init:
        # Install cpthook wrapper to configured repositories
        logging.info('Installing cpthook wrapper to repositories')
        install_hooks(config, opts)
    elif opts.hook:
        # Run requested hook on repository
        logging.info('Running {0} hooks'.format(opts.hook))
        run_hook(opts.hook, config, opts, hook_args)
    else:
        logging.debug('No command given.')
        print 'Use --help for assistance'
