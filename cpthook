#!/usr/bin/env python

import inspect
import git
import logging
import os.path
import subprocess
import sys

import cpthook


def parse_options():
    import optparse
    parser = optparse.OptionParser()
    parser.add_option("-c", "--config", dest="config_file", metavar="FILE",
                      default="hook.cfg", help="cpthook config file")
    parser.add_option("-v", "--verbose", dest="verbose", default=False,
                      action="store_true",
                      help="log verbose status information")
    parser.add_option("-d", "--debug", dest="debug", default=False,
                      action="store_true",
                      help="log debug information")
    parser.add_option("--dry-run", dest="dry_run", default=False,
                      action="store_true",
                      help="perform a dry run, making no changes")
    parser.add_option("--init", dest="init", default=False,
                      action="store_true",
                      help="install configured hooks and repositories")
    parser.add_option("--hook", dest="hook", default=None,
                      help="the hook to run against the current repository")
    options, args = parser.parse_args()
    return options, args


def validate_options(opts):
    if not os.path.isfile(opts.config_file):
        print 'No config file "{0}"'.format(opts.config_file)
        sys.exit(-1)

    if opts.init and opts.hook:
        print 'Cannot install to repos and be invoked as a hook'
        sys.exit(-1)

    if opts.hook is not None and opts.hook not in cpthook.supported_hooks:
        print 'Unsupported hook "{0}"'.format(opts.hook)
        sys.exit(-1)


def handle_options():
    opts, args = parse_options()
    validate_options(opts)

    if opts.debug:
        log_level = logging.DEBUG
    elif opts.verbose:
        log_level = logging.INFO
    else:
        log_level = logging.WARN
    logging.getLogger().setLevel(log_level)

    return opts, args


def install_hooks(config, opts):
    pass


def run_hook(hook, config, opts, args):
    try:
        gitrepo = git.Repo('.')
    except git.errors.InvalidGitRepositoryError:
        print '{0} is not a git repo?'.format(
            os.path.realpath(os.path.curdir))
        sys.exit(-1)
    # Work out the repository name from the current directory
    repo = os.path.basename(os.path.realpath(os.path.curdir))
    # Determine script path to be in cpthook directory.
    # Work out where that is through some introspection
    script_path = '/'.join((os.path.dirname(
        os.path.abspath(inspect.getfile(inspect.currentframe()))),
        'hooks.d', hook))
    # TODO: make script path a config option
    #script_path = '/'.join(opts.hooksd, hook)
    hooks = config.hooks_for_repo(repo)
    logging.info('{0}'.format(hooks))
    if hook in hooks:
        logging.info('Found {0} hooks'.format(hook))
        for script in hooks[hook]:
            logging.info('Running {0} hook {1}'.format(hook, script))
            if opts.dry_run:
                logging.info('Dry-run: skipping script {0}'.format(
                    script))
                continue
            logging.debug('Calling script {0}'.format(script))
            ret = subprocess.call(['/'.join((script_path, script))] + args)
            if ret != 0:
                logging.info(
                    'Received non-zero return code from {0}'.format(script))
                sys.exit(ret)
    sys.exit(0)


if __name__ == '__main__':
    # Any positional args returned by optparse are intended for
    # the hook script to be invoked.
    opts, hook_args = handle_options()

    try:
        config = cpthook.CptHookConfig(opts.config_file)
    except Exception, e:
        print 'Invalid cpthook config file {0}: {1}'.format(
            opts.config_file, str(e))
        # Exiting with a non-zero code has the potential to disrupt
        # legitimate activity to a repository if we are called as
        # a hook and the configuration file is broken. However, we
        # may also do damage by not running hook scripts that need
        # to run for repositories. It is therefore safest to exit
        # with a non-zero code as while inconvenient this has least
        # potential for damage.
        sys.exit(-1)

    if opts.init:
        # Install cpthook wrapper to configured repositories
        logging.info('Installing cpthook wrapper to repositories')
        install_hooks(config)
    elif opts.hook:
        # Run requested hook on repository
        logging.info('Running {0} hooks'.format(opts.hook))
        run_hook(opts.hook, config, opts, hook_args)
    else:
        logging.debug('No command given.')
        print 'Use --help for assistance'
